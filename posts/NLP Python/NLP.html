<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jasmine, Emma, Valorys, Yava">
<meta name="dcterms.date" content="2025-05-17">

<title>Can we distinguish AI from human writing?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<meta property="og:title" content="Can we distinguish AI from human writing?">
<meta property="og:description" content="">
<meta property="og:image" content="robot.png">
<meta name="twitter:title" content="Can we distinguish AI from human writing?">
<meta name="twitter:description" content="">
<meta name="twitter:image" content="robot.png">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../academic works.html" rel="" target="">
 <span class="menu-text">Academic projects</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about me.html" rel="" target="">
 <span class="menu-text">About me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/yava-vilar-valera-496999271/" rel="" target="">
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Can we distinguish AI from human writing?</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Jasmine, Emma, Valorys, Yava </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">May 17, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>In recent years, the emergence of tools like ChatGPT have made it increasingly common to generate texts using artificial intelligence. This raises the question of whether it is possible to distinguish between human-written and machine-generated text. While in some cases it might be difficult to answer this question based on human judgment alone, natural language processing (NLP) techniques and machine learning models can be trained to learn from the discrepancies between human- and AI-written texts, and then classify and predict the likelihood that a given text was produced by a non-human author. To achieve this, it is necessary to have a dataset containing essay excerpts that we can confidently attribute to either source. Access to <a href="NLP.pdf">full analysis</a> and to Python <a href="https://github.com/YavaVilar/SVM/blob/main/Code%20NLP.ipynb">code</a>.</p>
<section id="data-and-preprocessing" class="level4">
<h4 class="anchored" data-anchor-id="data-and-preprocessing">Data and Preprocessing</h4>
<p>The analysis was conducted on a dataset from Kaggle, containing 10,000 short English texts. Each entry was labeled with a binary variable: generated = 1 for AI-generated text and 0 for human-written. In order to analyze the data, the texts underwent some necessary standard preprocessing steps:</p>
<ul>
<li><p>Stopword removal: Common but uninformative words such as “the” or “is” were excluded.</p></li>
<li><p>Lemmatization: Words were reduced to their base form (e.g., “running” → “run”).</p></li>
<li><p>Tokenization: Texts were segmented into meaningful units (tokens).</p></li>
<li><p>Text Representation: TF-IDF To feed the texts into machine learning models, the TF-IDF (Term Frequency-Inverse Document Frequency) method was used to transform textual data into numerical vectors. TF-IDF assigns higher weight to words that are frequent in a document but rare across the corpus, allowing the model to identify distinctive terms.</p></li>
</ul>
</section>
<section id="exploratory-analysis-of-textual-features" class="level4">
<h4 class="anchored" data-anchor-id="exploratory-analysis-of-textual-features">Exploratory Analysis of Textual Features</h4>
<p>Beyond model training, the project also involved a deep exploration of the texts’ linguistic characteristics.</p>
<p>On the one hand, a variety of syntactic and stylistic features were extracted and compared between AI- and human-generated texts: use of punctuation, average sentence length, number of paragraphs, grammatical quality (spelling and coherence), sentence complexity (syntactic depth), readability (Flesch index), lexical diversity, frequency of grammatical categories (nouns, verbs, adverbs), and semantic coherence (cosine similarity between sentence embeddings)</p>
<ul>
<li><strong>Results:</strong> These analyses revealed that human-written texts tend to show greater variability, richer structure, and a more diverse use of grammar, while AI-generated texts are generally more formal, uniform, and neutral in tone.</li>
</ul>
<p>In addition, we visualized the words frequency by plotting word clouds, as demonstrated in the following figure.</p>
<p><img src="images/clipboard-2636228377.png" class="img-fluid" width="633"></p>
<p>We can highligh a first notable difference between the two categories: human-written texts contain several highly frequent, often repeated words (“people,” “think,” etc.), while AI-generated texts present a more diverse lexicon, with a more evenly distributed frequency. A notable exception is “electoral college,” which appears frequently in both corpora. These elements suggest a tendency for humans to repeat themselves more, whereas AI mobilizes a more extensive vocabulary.</p>
</section>
<section id="sentiment-and-topic-modeling" class="level4">
<h4 class="anchored" data-anchor-id="sentiment-and-topic-modeling"><strong>Sentiment and Topic Modeling</strong></h4>
<section id="topic-modeling" class="level5">
<h5 class="anchored" data-anchor-id="topic-modeling">- Topic Modeling</h5>
<p>We now move on to identifying the topics present in the texts. The objective is to highlight the major topics addressed in each category (human vs.&nbsp;generated texts). To do this, we used the Latent Dirichlet Allocation (LDA) method, a topic modeling algorithm that automatically detects groups of co-occurring words reflecting three latent themes defined in our study. To obtain interpretable results, we first imposed rules on the text-to-digital conversion using the CountVectorizer function, such as: excluding words that appear in more than 90% of paragraphs, deleting words contained in fewer than two paragraphs, and ignoring stopwords from the English dictionary. The figure below shows the top 15 most frequent words in each of the topics. From these words, we can infer latent variables.</p>
<p><img src="images/clipboard-642307047.png" class="img-fluid" width="584"></p>
<p>The first topic seem to concern learning, education, and technology. Indeed, words related to school, teaching, and technology are prominent, accompanied by other, more general terms such as “life,” “help,” and “people.” This suggests that this topic is quite broad, encompassing personal or academic learning in a digital or scientific context. The second topic evokes politics and the electoral system, with terms specific to these themes such as “election,” “candidate,” “vote,” “president,” and “electoral.” Finally, the last top 15 refers to the transportation dimension, with modern issues such as pollution, urban mobility, autonomous cars, and sustainability all referred to by “pollution,” “driverless,” “usage,” and “reduce.”</p>
</section>
<section id="sentiment-analysis" class="level5">
<h5 class="anchored" data-anchor-id="sentiment-analysis">- Sentiment analysis</h5>
<p>Then, we performed the sentiment analysis using the VADER (Valence Aware Dictionary for Sentiment Reasoning) method, which involves assigning a polarity score to each text: a score greater than 0.05 = a “positive” text, a score of zero = a “neutral” text, and a score less than -0.05 = a “negative” text.</p>
<p><img src="images/clipboard-1334929739.png" class="img-fluid" width="580"></p>
<p>Figure above shows that topics related to education (topic 0) and politics (topic 1) show a very strong predominance of positive sentiments, with 95% and 94% of texts having a positive tone, respectively. We can also observe that the AI-generated texts present a lower proportion of negative sentiments (5% versus 12% for human texts) and a higher proportion of positive sentiments (95% versus 87%). Thus, the AI ​​productions appear overall more positive and less polarized than those of humans.</p>
</section>
</section>
<section id="classification-models" class="level4">
<h4 class="anchored" data-anchor-id="classification-models">Classification Models</h4>
<p>Five supervised machine learning models were tested: Logistic Regression, Linear SVC (Support Vector Classifier), Non-linear SVC, Random Forest, and Multinomial Naive Bayes. Each model was evaluated using two key metrics: Accuracy: The percentage of correctly classified texts, and F1-score: A balance between precision and recall, especially useful to assess model robustness when categories are unbalanced (more observations of one category than the other).</p>
<p>These results demonstrate that traditional NLP techniques and classic machine learning models are effective at distinguishing between AI-generated and human-written texts, even without access to deep learning models. In particular, the LinearSVC model delivered the best generalization performance with a training accuracy of 99.7% and a test accuracy of 97.9%, followed closely by logistic regression and random forest. The non-linear SVC underperformed due to poor generalization (around 50% of accuracy).</p>
<p>Figure below represents the confusion matrix from our best model: LinearSVC. We observe that only 29 out of 1,537 texts were falsely predicted as AI-generated when they were actually human-generated, while only 33 out of 1,463 texts were incorrectly classified as human-generated when they were AI-generated. This confirms the robustness of our model.</p>
<p><img src="images/clipboard-836968440.png" class="img-fluid" width="538"></p>
</section>
<section id="conclusion" class="level4">
<h4 class="anchored" data-anchor-id="conclusion">Conclusion</h4>
<p>The study confirms that there are identifiable linguistic and structural differences between AI- and human-generated texts, and that it is feasible to automate the detection process using NLP and machine learning. The LinearSVC model, in particular, proved to be well-suited for high-dimensional sparse data like TF-IDF vectors.</p>
<p>However, there are also certain limitations: The dataset consists of a single type of short-form text, limiting generalizability. Likewise, the dataset was likely balanced and annotated artificially, which may not reflect real-world distributions. In future works, we could integrate deeper linguistic variables (e.g., rhetorical structure, discourse markers), use advanced language models such as BERT or RoBERTa, and expand the analysis to more diverse text genres (e.g., tweets, dialogue, narratives).</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="https://www.quarto.org">Built with Quarto | RStudio</a>
  </li>  
</ul>
    </div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>



</body></html>